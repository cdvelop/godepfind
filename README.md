# godepfind
<!-- START_SECTION:BADGES_SECTION -->
<a href="docs/img/badges.svg"><img src="docs/img/badges.svg" alt="Project Badges" title="Generated by badges.sh from github.com/cdvelop/devscripts"></a>
<!-- END_SECTION:BADGES_SECTION -->

A Go library for finding reverse dependencies and determining which main packages are affected by file changes.

## Overview

`godepfind` helps you identify which packages import your target packages (reverse dependency analysis) and, more importantly, **which main packages need to be recompiled when you modify a specific Go file**.

This is particularly useful for:
- **Build systems** that need to know which applications to rebuild when files change
- **Development tools** that optimize compilation by only rebuilding affected main packages
- **CI/CD pipelines** that want to minimize build time by targeting only affected applications

## Installation

```bash
go get github.com/cdvelop/godepfind
```

## Features

### 1. Cached Dependency Analysis
**NEW**: Intelligent caching system for performance in development environments where files change regularly.

### 2. Handler-Based File Ownership
**NEW**: Determine which handler should process a file change using smart dependency analysis.

### 3. Find Reverse Dependencies
Find which packages import specified target packages.

### 4. File-to-Main Mapping  
**Main feature**: Given a modified file name, find which main packages depend on it (directly or transitively).

## Usage

### Basic Setup

```go
import "github.com/cdvelop/godepfind"

// Create a new finder instance for your project
finder := godepfind.New("/path/to/your/go/project")

// Optional: Include test imports in dependency analysis
finder.SetTestImports(true)
```

### Find Which Main Packages Use a File

**Primary use case**: When you modify a file, find which main packages need recompilation.

```go
// After modifying "database.go", find affected main packages
mains, err := finder.GoFileComesFromMain("database.go")
if err != nil {
    log.Fatal(err)
}

fmt.Printf("Main packages affected by database.go changes: %v\n", mains)
// Output: [myproject/cmd/server myproject/cmd/cli]
```

### Handler-Based File Ownership (NEW)

**For development tools**: Determine which handler should process a file change.

```go
// Define a handler that manages specific main files
type MyHandler struct {
    name string
}

func (h *MyHandler) Name() string {
    return "serverHandler"
}

func (h *MyHandler) UnobservedFiles() []string {
    return []string{"main.server.go", "server"}
}

// Check if a file change belongs to this handler
handler := &MyHandler{}
isMine, err := finder.ThisFileIsMine(handler, "database.go", "./internal/db/database.go", "write")
if err != nil {
    log.Fatal(err)
}

if isMine {
    fmt.Println("This handler should process the file change")
    // Process the file change...
}
```

### Find Reverse Dependencies

```go
// Find packages that import "fmt" or "os"
deps, err := finder.FindReverseDeps("./...", []string{"fmt", "os"})
if err != nil {
    log.Fatal(err)
}

fmt.Printf("Packages importing fmt or os: %v\n", deps)
```

## Real-World Example

Imagine you have a Go project with multiple applications:

```
myproject/
â”œâ”€â”€ go.mod
â”œâ”€â”€ cmd/
â”‚   â”œâ”€â”€ server/main.go      (web server)
â”‚   â”œâ”€â”€ cli/main.go         (command line tool)  
â”‚   â””â”€â”€ worker/main.go      (background worker)
â”œâ”€â”€ internal/
â”‚   â”œâ”€â”€ database/db.go      (shared database package)
â”‚   â”œâ”€â”€ auth/auth.go        (authentication)
â”‚   â””â”€â”€ utils/helpers.go    (utilities)
```

**Scenario**: You modify `internal/database/db.go`

```go
finder := godepfind.New("/path/to/myproject")

// Traditional approach: Find which main packages are affected
affected, err := finder.GoFileComesFromMain("db.go")
if err != nil {
    log.Fatal(err)
}

fmt.Printf("Need to rebuild: %v\n", affected)
// Output: [myproject/cmd/server myproject/cmd/worker]
// Note: cmd/cli is NOT affected because it doesn't import the database package

// NEW: Handler-based approach for development tools
type ServerHandler struct{}

func (h *ServerHandler) Name() string {
    return "serverH"
}

func (h *ServerHandler) UnobservedFiles() []string {
    return []string{"main.server.go", "server"}
}

// Check if server handler should process this change
serverHandler := &ServerHandler{}
shouldProcess, err := finder.ThisFileIsMine(serverHandler, "db.go", "./internal/database/db.go", "write")
if err != nil {
    log.Fatal(err)
}

if shouldProcess {
    fmt.Println("Server handler will process this database change")
    // Automatically compile server, restart, etc.
}
```

Now your build system knows to only recompile the `server` and `worker` applications, not the `cli` tool.

## API Reference

### Core Functions

### `New(rootDir string) *GoDepFind`
Creates a new GoDepFind instance with intelligent caching.
- `rootDir`: Path to the Go module root directory (where go.mod is located)

### `SetTestImports(enabled bool)`
Enable/disable inclusion of test imports in dependency analysis.

### `GoFileComesFromMain(fileName string) ([]string, error)`
**Main function**: Find which main packages depend on the given file.
- `fileName`: Name of the file (e.g., "database.go", "helpers.go")
- Returns: Slice of main package paths that depend on this file

### `FindReverseDeps(sourcePath string, targetPaths []string) ([]string, error)`
Find packages in sourcePath that import any of the targetPaths.
- `sourcePath`: Path pattern to search (e.g., "./...", "./cmd/...")
- `targetPaths`: Packages to find dependencies for
- Returns: Slice of packages that import the targets

### New Cache-Enabled Functions

### `ThisFileIsMine(dh DepHandler, fileName, filePath, event string) (bool, error)`
**NEW**: Determine if a file change belongs to a specific handler using intelligent dependency analysis.
- `dh`: Handler implementing the DepHandler interface
- `fileName`: Name of the changed file
- `filePath`: Full path to the changed file  
- `event`: Type of change ("write", "create", "remove", "rename")
- Returns: (true if handler should process, error if any)

### DepHandler Interface

```go
type DepHandler interface {
    Name() string              // Unique handler name
    UnobservedFiles() []string // Main files this handler manages
}
```

Implement this interface in your handlers to use the smart file ownership detection.

## Performance & Caching


`godepfind` now includes an intelligent caching system that dramatically improves performance in development environments:

### ðŸ“Š Benchmark Summary

| Scenario                | Without Cache      | With Cache         | Speedup   |
|------------------------|--------------------|--------------------|-----------|
| GoFileComesFromMain    | ~15,300,000 ns/op  | ~210 ns/op         | ~70,000x  |
| ThisFileIsMine         | ~15,200,000 ns/op  | ~310 ns/op         | ~49,000x  |
| Real-World Scenario    | ~5,000,000 ns/op   | ~310 ns/op*        | ~16,000x* |
| Multiple Files         | ~61,200,000 ns/op  | ~890 ns/op         | ~68,000x  |
| Cache Invalidation     | N/A                | ~305 ns/op         | -         |

*See [docs/BENCHMARK.md](docs/BENCHMARK.md) for full results and details.*

*Note: Real-World Scenario with cache is extremely fast; actual value is similar to other cached operations.*

> **Expert Note:**
> GoDepFind's cache system achieves real-time performance (from ~15,000,000 ns/op to ~210 ns/op, ~70,000x faster) and reduces memory allocations to nearly zero in repeated queries. This makes it highly suitable for modern development environments, file watchers, and incremental build systems.

- **Lazy Loading**: Cache is built only when needed
- **Selective Invalidation**: Only affected packages are re-analyzed when files change
- **Memory Efficient**: Cache is stored in memory and cleaned up automatically
- **Event-Driven**: Cache updates automatically based on file change events


This makes `godepfind` suitable for real-time file watching in development tools.

## Use Cases

1. **Smart Build Systems**: Only rebuild applications affected by code changes with automatic cache management
2. **Development Tools**: IDE extensions that show which apps are affected by current changes  
3. **File Watchers**: Real-time development environments that respond to file changes intelligently
4. **CI/CD Optimization**: Reduce build time by targeting only affected main packages
5. **Dependency Analysis**: Understand how your modules are interconnected
6. **Refactoring Safety**: Know the blast radius of changes before making them

## Requirements

- Go 1.19+
- Valid Go module (go.mod file)
- Project must be buildable with `go list ./...`

## Acknowledgments

This library is based on the excellent work of [Andrew Wilkins](https://github.com/axw) and his [rdep](https://github.com/axw/rdep) tool. The core reverse dependency detection logic was adapted and extended from his implementation to provide file-to-main package mapping functionality.

Special thanks to Andrew for creating the foundational reverse dependency analysis that made this library possible.
